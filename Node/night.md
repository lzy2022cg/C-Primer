## 9.1 顺序容器概述
### 以下是选择容器的基本原则：
- 除非你有很好的理由选择其他容器，否则应使用vector。
- 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。
- 如果程序要求随机访问元素，应使用vector或deque。
- 如果程序要求在容器的中间插入或删除元素，应使用list或forward_list。
- 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。
- 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
  - 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数（我们将在10.2.3节介绍sort（第343页））来重排容器中的元素，从而避免在中间位置添加元素。
  -  如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。
 ### 注意：
> 如果程序既需要随机访问元素，又需要在容器中间位置插入元素，那该怎么办？答案取决于在list或forward_list中访问元素与vector或deque中插入/删除元素的相对性能。一般来说，应用中占主导地位的操作（`执行的访问操作更多还是插入/删除更多`）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。
如果你不确定应该使用哪种容器，那么可以在程序中只使用vector和list公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用vector或list都很方便。

### 容器库概览
#### 容器类型上的操作：
- 某些操作是所有容器类型都提供的（参见表9.2，第295页）。
- 另外一些操作仅针对顺序容器（`参见表9.3，第299页`）、关联容器（`参见表11.7，第388页`）或无序容器（`参见表11.8，第395页`）。
- 还有一些操作只适用于一小部分容器。

## 9.2 容器库概览 
### 构造函数

| 定义和初始化 | 解释 |
|-----|-----|
| `C c;` | 默认构造函数，如果c是一个array，则c中元素按默认方式初始化；否则c为空 |
| `C c1(c2);` 等价于 `C c1 = c2;` | c1初始化为c2的拷贝。c1必须和c2是相同类类型且保存的是相同的元素类型；对于array类型，两者还必须有相同的大小 |
| `C c{a,b,c...}` 等价于 `C c={a,b,c...}` | C初始化为初始化列表中元素的拷贝。列表中元素的类型必须与C的元素类型相容。array类型还要求元素数目与array大小相同，任何遗漏的元素都会被初始化 |
| `C c(b, e)` | c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与的元素类型相容（array不适用） |
| 只有顺序容器（不包括array）的构造函数才能接受大小参数 |
| `C seq(n)` | seq包含`n`个元素，这些元素进行了值初始化；此构造函数时explicit的 |
| `C seq(n, t)` | seq包含`n`个初始值为`t`的元素 |

- 只有顺序容器的构造函数才接受大小参数（array除外） ，关联容器并不支持。
- `array`具有固定大小。
- 和其他容器不同，默认构造的`array`是非空的。
- 直接复制：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。
- 使用迭代器复制：不要求容器类型相同，容器内的元素类型也可以不同。

### 赋值和`swap`

| 操作 | 解释 |
|-----|-----|
| `c1 = c2;` | 将`c1`中的元素替换成`c2`中的元素 |
| `c1 = {a, b, c...}` | 将`c1`中的元素替换成列表中的元素（不适用于`array`） |
| `c1.swap(c2)` | 交换`c1`和`c2`的元素 |
| `swap(c1, c2)` | 等价于`c1.swap(c2)` |
| `c.assign(b, e)` | 将`c`中的元素替换成迭代器`b`和`e`表示范围中的元素，`b`和`e`不能指向`c`中的元素 |
| `c.assign(il)` | 将`c`中的元素替换成初始化列表`il`中的元素 |
| `c.assign(n, r)` | 将`c`中的元素替换为`n`个值是`t`的元素 |

- 使用非成员版本的`swap`是一个好习惯。
- `assign`操作不适用于关联容器和`array`
